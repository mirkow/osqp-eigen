<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>osqp-eigen: osqp-eigen</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">osqp-eigen
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">osqp-eigen </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
 A simple C++ Eigen wrapper for <a href="https://osqp.org/" target="_blank"><b>osqp library</b></a>. </p><dl class="section author"><dt>Author</dt><dd>Giulio Romualdi <a href="#" onclick="location.href='mai'+'lto:'+'giu'+'li'+'o.r'+'om'+'ual'+'di'+'@ii'+'t.'+'it'; return false;">giuli<span style="display: none;">.nosp@m.</span>o.ro<span style="display: none;">.nosp@m.</span>muald<span style="display: none;">.nosp@m.</span>i@ii<span style="display: none;">.nosp@m.</span>t.it</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>License terms, released under the terms of the GNU LGPL v3.0.</dd></dl>
<h1><a class="anchor" id="build-section"></a>
How to build the wrapper</h1>
<p>Please run the following command in your terminal </p><div class="fragment"><div class="line">git clone https://github.com/robotology/osqp-eigen.git</div><div class="line">cd osqp-eigen</div><div class="line">mkdir build &amp;&amp; cd build</div><div class="line">cmake ../</div><div class="line">make</div><div class="line">[sudo] make install</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><code>sudo</code> is not necessary if you specify the <code>CMAKE_INSTALL_PREFIX</code>. In this case it is necessary to add in the <code>.bashrc</code> the following lines: <div class="fragment"><div class="line">export OsqpEigen_DIR=/path/where/you/installed/</div></div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="use-section"></a>
How to embed the wrapper inside your project</h1>
<p>osqp-eigen provides native CMake support which allows the library to be easily used in CMake projects. </p><dl class="section note"><dt>Note</dt><dd>CMake 3.0 (or later) is required to enable this functionality.</dd></dl>
<p>osqp-eigen exports a CMake target called <code>OsqpEigen::OsqpEigen</code> which can be imported using the <code>find_package</code> CMake command and used by calling <code>target_link_libraries</code> as fllows: </p><div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.0)</div><div class="line">find_package(OsqpEigen REQUIRED)</div><div class="line">add_executable(myproject src/main.cpp)</div><div class="line">target_link_libraries(myproject OsqpEigen::OsqpEigen osqp::osqp Eigen3::Eigen)</div></div><!-- fragment --><p> Eigen and osqp libraries are required by the wrapper.</p>
<h1><a class="anchor" id="example-section"></a>
How to implement an MPC controller with osqp-eigen</h1>
<p>In this section a simple implementation of a MPC controller using osqp-eigen is shown. <a href="http://osqp.readthedocs.io/en/latest/examples/mpc.html"><b>Here</b></a> you can find the original version of this example.</p>
<p>For further details please refer to the <a href="https://github.com/GiulioRomualdi/osqp-eigen/blob/master/example/src/MPCExample.cpp" target="_blank"><b>code</b></a>.</p>
<h2><a class="anchor" id="MPCPROBLEM"></a>
Problem</h2>
<p>The problem is to develop a controller that allows a linear system to track a constant reference state \(x_r\). This kind of problem can be solved using a lot of different controller architectures, however in order to write a tutorial for osqp-eigen library the <a href="https://en.wikipedia.org/wiki/Model_predictive_control"><b>MPC</b></a> approach will be chosen. Thus we have to find a controller low \(u_0^*\) such that: </p><p class="formulaDsp">
\[ \begin{split}\begin{array}{ll} u_0 ^* = \mbox{arg min}_{x_k, u_k} &amp; (x_N-x_r)^T Q_N (x_N-x_r) + \sum_{k=0}^{N-1} (x_k-x_r)^T Q (x_k-x_r) + u_k^T R u_k \\ \mbox{subject to} &amp; x_{k+1} = A x_k + B u_k \\ &amp; x_{\rm min} \le x_k \le x_{\rm max} \\ &amp; u_{\rm min} \le u_k \le u_{\rm max} \\ &amp; x_0 = \bar{x} \end{array}\end{split} \]
</p>
<p> where \(Q\), \(Q_N\) and \(R\) are symmetric positive definite matrices; the states \(x_k\) and the inputs \(u_k\) have to be constrained between some lower and upper bounds and the reference state \(x_r\) is </p><p class="formulaDsp">
\[ x_r = \begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix} ^T \]
</p>
<h2><a class="anchor" id="MPC2QP"></a>
MPC to QP</h2>
<p>First of all the MPC problem has to be casted to a standard QP problem. </p><p class="formulaDsp">
\[ \begin{split}\begin{array}{ll} \mbox{minimize} &amp; \frac{1}{2} x^T P x + q^T x \\ \mbox{subject to} &amp; l \leq A_c x \leq u \end{array}\end{split} \]
</p>
<p> where the hessian matrix \(P\) is equal to </p><p class="formulaDsp">
\[ P = \text{diag}(Q, Q, ..., Q_N, R, ..., R) \]
</p>
<p> while the gradient vector is </p><p class="formulaDsp">
\[ q = \begin{bmatrix} -Q x_r \\ -Q x_r \\ \vdots \\ -Q_N x_r \\ 0\\ \vdots\\ 0 \end{bmatrix} \]
</p>
<p>The linear constraint matrix \(A_c\) is </p><p class="formulaDsp">
\[ A_c = \left[ \begin{array}{ccccc|cccc} -I &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\ A &amp; -I &amp; 0 &amp; \cdots &amp; 0 &amp; B &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; A &amp; -I &amp; \cdots &amp; 0 &amp; 0 &amp; B &amp; \cdots &amp; 0\\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; -I &amp; 0 &amp; 0 &amp; \cdots &amp; B\\ \hline I &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\ 0 &amp; I &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\ 0 &amp; 0 &amp; I &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; I &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; I &amp; 0 &amp; \cdots &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; I &amp; \cdots &amp; 0\\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; I \end{array} \right] \]
</p>
<p> while the upper and the lower bound are </p><p class="formulaDsp">
\[ l = \begin{bmatrix} -x_0 \\ 0 \\ \vdots \\ 0 \\ x_{min}\\ \vdots\\ x_{min}\\ u_{min}\\ \vdots\\ u_{min}\\ \end{bmatrix} \quad u = \begin{bmatrix} -x_0 \\ 0 \\ \vdots \\ 0 \\ x_{max}\\ \vdots\\ x_{max}\\ u_{max}\\ \vdots\\ u_{max}\\ \end{bmatrix} \]
</p>
<p>Since the osqp-eigen handles only QP problem this operation shall be done by the user. You can find the implementation of the following functions <a href="https://github.com/GiulioRomualdi/osqp-eigen/blob/master/example/src/MPCExample.cpp#L71-L182"><b>here</b></a>. </p><div class="fragment"><div class="line">castMPCToQPHessian(Q, R, mpcWindow, hessian);</div><div class="line">castMPCToQPGradient(Q, xRef, mpcWindow, gradient);</div><div class="line">castMPCToQPConstraintMatrix(a, b, mpcWindow, linearMatrix);</div><div class="line">castMPCToQPConstraintVectores(xMax, xMin, uMax, uMin, x0, mpcWindow, lowerBound, upperBound);</div></div><!-- fragment --><h2><a class="anchor" id="OSQP_init"></a>
Solver initialization</h2>
<p>Now you are able to use the OSQP solver. We first create an instance of the solver </p><div class="fragment"><div class="line"><span class="comment">// instantiate the solver</span></div><div class="line"><a class="code" href="classOsqpEigen_1_1Solver.html">OsqpEigen::Solver</a> solver;</div></div><!-- fragment --><p> when the solver is instantiated the <a href="http://osqp.readthedocs.io/en/latest/interfaces/solver_settings.html"><b>default settings</b></a> are automatically loaded, however you can change each setting using the following function </p><div class="fragment"><div class="line">solver.<a class="code" href="classOsqpEigen_1_1Solver.html#ad355be214417b0ccb1ec54913fe378c4">settings</a>()-&gt;set&lt;Setting&gt;()</div></div><!-- fragment --><p> where <code>set&lt;Setting&gt;()</code> is a setter function. You can find the list of all the setter functions in the <code><a class="el" href="classOsqpEigen_1_1Settings.html" title="settings class is a wrapper of the OSQP OSQPSettings struct. ">OsqpEigen::Settings</a></code> class. For example you can use the warm start variables in the optimization problem by calling </p><div class="fragment"><div class="line">solver.<a class="code" href="classOsqpEigen_1_1Solver.html#ad355be214417b0ccb1ec54913fe378c4">settings</a>()-&gt;setWarmStart(<span class="keyword">true</span>);</div></div><!-- fragment --><p>Now you can set the data of the optimization problem (number of variables, number of constraints and so on) </p><div class="fragment"><div class="line">solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setNumberOfVariables(numberOfVariable);</div><div class="line">solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setNumberOfConstraints(numberOfConstraints);</div><div class="line"><span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setHessianMatrix(hessian)) <span class="keywordflow">return</span> 1;</div><div class="line"><span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setGradient(gradient)) <span class="keywordflow">return</span> 1;</div><div class="line"><span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setLinearConstraintMatrix(linearMatrix)) <span class="keywordflow">return</span> 1;</div><div class="line"><span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setLowerBound(lowerBound)) <span class="keywordflow">return</span> 1;</div><div class="line"><span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setUpperBound(upperBound)) <span class="keywordflow">return</span> 1;</div></div><!-- fragment --><p> The setter functions return <code>True</code> in case of success and <code>False</code> otherwise.</p>
<p>Now you are able to initialize the solver. All data and settings will be stored inside the osqp struct and the optimization problem will be initialized. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a8487090a685d7653ea4011971c2f21f7">initSolver</a>()) <span class="keywordflow">return</span> 1;</div></div><!-- fragment --><p>The optimization problem can be solved calling the following method </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#aade83b0e68b85d47d41a054f04d413aa">solve</a>()) <span class="keywordflow">return</span> 1;</div></div><!-- fragment --><p> and the solution can be easily got by calling the following method </p><div class="fragment"><div class="line">Eigen::VectorXd QPSolution = solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a192a5f94034d4e467c6b557c2e06dd66">getSolution</a>();</div></div><!-- fragment --><p>If you need to update the bounds constraints and the gradient vector you can use the following methods:</p><ul>
<li><code><a class="el" href="classOsqpEigen_1_1Solver.html#a1af39f37500a6bad6896e8e6699880fa" title="Update both upper and lower bounds (size m). ">OsqpEigen::Solver::updateBounds</a></code> to update both upper and lower bounds;</li>
<li><code><a class="el" href="classOsqpEigen_1_1Solver.html#a48764153cec5e618021ab79586cc71b6" title="Update the lower bounds limit (size m). ">OsqpEigen::Solver::updateLowerBound</a></code> to update the lower bound;</li>
<li><code><a class="el" href="classOsqpEigen_1_1Solver.html#a69f1db45e10dae9c186cc0561532f018" title="Update the upper bounds limit (size m). ">OsqpEigen::Solver::updateUpperBound</a></code> to update the upper bound;</li>
<li><code><a class="el" href="classOsqpEigen_1_1Solver.html#a7d1d9fdd8db3201a0ca2dcafbc289eea" title="Update the linear part of the cost function (Gradient). ">OsqpEigen::Solver::updateGradient</a></code> to update the gradient vector.</li>
</ul>
<h2><a class="anchor" id="results"></a>
Example</h2>
<p>In the following the example of MPC controller is shown. </p><div class="fragment"><div class="line"></div><div class="line"><span class="comment">// osqp-eigen</span></div><div class="line"><span class="preprocessor">#include &quot;OsqpEigen/OsqpEigen.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// eigen</span></div><div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setDynamicsMatrices(Eigen::Matrix&lt;double, 12, 12&gt; &amp;a, Eigen::Matrix&lt;double, 12, 4&gt; &amp;b)</div><div class="line">{</div><div class="line">    a &lt;&lt; 1.,      0.,     0., 0., 0., 0., 0.1,     0.,     0.,  0.,     0.,     0.    ,</div><div class="line">        0.,      1.,     0., 0., 0., 0., 0.,      0.1,    0.,  0.,     0.,     0.    ,</div><div class="line">        0.,      0.,     1., 0., 0., 0., 0.,      0.,     0.1, 0.,     0.,     0.    ,</div><div class="line">        0.0488,  0.,     0., 1., 0., 0., 0.0016,  0.,     0.,  0.0992, 0.,     0.    ,</div><div class="line">        0.,     -0.0488, 0., 0., 1., 0., 0.,     -0.0016, 0.,  0.,     0.0992, 0.    ,</div><div class="line">        0.,      0.,     0., 0., 0., 1., 0.,      0.,     0.,  0.,     0.,     0.0992,</div><div class="line">        0.,      0.,     0., 0., 0., 0., 1.,      0.,     0.,  0.,     0.,     0.    ,</div><div class="line">        0.,      0.,     0., 0., 0., 0., 0.,      1.,     0.,  0.,     0.,     0.    ,</div><div class="line">        0.,      0.,     0., 0., 0., 0., 0.,      0.,     1.,  0.,     0.,     0.    ,</div><div class="line">        0.9734,  0.,     0., 0., 0., 0., 0.0488,  0.,     0.,  0.9846, 0.,     0.    ,</div><div class="line">        0.,     -0.9734, 0., 0., 0., 0., 0.,     -0.0488, 0.,  0.,     0.9846, 0.    ,</div><div class="line">        0.,      0.,     0., 0., 0., 0., 0.,      0.,     0.,  0.,     0.,     0.9846;</div><div class="line"></div><div class="line">    b &lt;&lt; 0.,      -0.0726,  0.,     0.0726,</div><div class="line">        -0.0726,  0.,      0.0726, 0.    ,</div><div class="line">        -0.0152,  0.0152, -0.0152, 0.0152,</div><div class="line">        -0.,     -0.0006, -0.,     0.0006,</div><div class="line">        0.0006,   0.,     -0.0006, 0.0000,</div><div class="line">        0.0106,   0.0106,  0.0106, 0.0106,</div><div class="line">        0,       -1.4512,  0.,     1.4512,</div><div class="line">        -1.4512,  0.,      1.4512, 0.    ,</div><div class="line">        -0.3049,  0.3049, -0.3049, 0.3049,</div><div class="line">        -0.,     -0.0236,  0.,     0.0236,</div><div class="line">        0.0236,   0.,     -0.0236, 0.    ,</div><div class="line">        0.2107,   0.2107,  0.2107, 0.2107;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setInequalityConstraints(Eigen::Matrix&lt;double, 12, 1&gt; &amp;xMax, Eigen::Matrix&lt;double, 12, 1&gt; &amp;xMin,</div><div class="line">                              Eigen::Matrix&lt;double, 4, 1&gt; &amp;uMax, Eigen::Matrix&lt;double, 4, 1&gt; &amp;uMin)</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> u0 = 10.5916;</div><div class="line"></div><div class="line">    <span class="comment">// input inequality constraints</span></div><div class="line">    uMin &lt;&lt; 9.6 - u0,</div><div class="line">        9.6 - u0,</div><div class="line">        9.6 - u0,</div><div class="line">        9.6 - u0;</div><div class="line"></div><div class="line">    uMax &lt;&lt; 13 - u0,</div><div class="line">        13 - u0,</div><div class="line">        13 - u0,</div><div class="line">        13 - u0;</div><div class="line"></div><div class="line">    <span class="comment">// state inequality constraints</span></div><div class="line">    xMin &lt;&lt; -M_PI/6,-M_PI/6,-<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,-<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,-<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,-1.,</div><div class="line">        -<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>, -<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,-<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,-<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,</div><div class="line">        -<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,-<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>;</div><div class="line"></div><div class="line">    xMax &lt;&lt; M_PI/6,M_PI/6, <a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,</div><div class="line">        <a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>, <a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,</div><div class="line">        <a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>,<a class="code" href="namespaceOsqpEigen.html#acfe9d2ea05e99677c0dc9e8f5646098d">OsqpEigen::INFTY</a>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setWeightMatrices(Eigen::DiagonalMatrix&lt;double, 12&gt; &amp;Q, Eigen::DiagonalMatrix&lt;double, 4&gt; &amp;R)</div><div class="line">{</div><div class="line">    Q.diagonal() &lt;&lt; 0, 0, 10., 10., 10., 10., 0, 0, 0, 5., 5., 5.;</div><div class="line">    R.diagonal() &lt;&lt; 0.1, 0.1, 0.1, 0.1;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> castMPCToQPHessian(<span class="keyword">const</span> Eigen::DiagonalMatrix&lt;double, 12&gt; &amp;Q, <span class="keyword">const</span> Eigen::DiagonalMatrix&lt;double, 4&gt; &amp;R, <span class="keywordtype">int</span> mpcWindow,</div><div class="line">                        Eigen::SparseMatrix&lt;double&gt; &amp;hessianMatrix)</div><div class="line">{</div><div class="line"></div><div class="line">    hessianMatrix.resize(12*(mpcWindow+1) + 4 * mpcWindow, 12*(mpcWindow+1) + 4 * mpcWindow);</div><div class="line"></div><div class="line">    <span class="comment">//populate hessian matrix</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;12*(mpcWindow+1) + 4 * mpcWindow; i++){</div><div class="line">        <span class="keywordflow">if</span>(i &lt; 12*(mpcWindow+1)){</div><div class="line">            <span class="keywordtype">int</span> posQ=i%12;</div><div class="line">            <span class="keywordtype">float</span> value = Q.diagonal()[posQ];</div><div class="line">            <span class="keywordflow">if</span>(value != 0)</div><div class="line">                hessianMatrix.insert(i,i) = value;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span>{</div><div class="line">            <span class="keywordtype">int</span> posR=i%4;</div><div class="line">            <span class="keywordtype">float</span> value = R.diagonal()[posR];</div><div class="line">            <span class="keywordflow">if</span>(value != 0)</div><div class="line">                hessianMatrix.insert(i,i) = value;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> castMPCToQPGradient(<span class="keyword">const</span> Eigen::DiagonalMatrix&lt;double, 12&gt; &amp;Q, <span class="keyword">const</span> Eigen::Matrix&lt;double, 12, 1&gt; &amp;xRef, <span class="keywordtype">int</span> mpcWindow,</div><div class="line">                         Eigen::VectorXd &amp;gradient)</div><div class="line">{</div><div class="line"></div><div class="line">    Eigen::Matrix&lt;double,12,1&gt; Qx_ref;</div><div class="line">    Qx_ref = Q * (-xRef);</div><div class="line"></div><div class="line">    <span class="comment">// populate the gradient vector</span></div><div class="line">    gradient = Eigen::VectorXd::Zero(12*(mpcWindow+1) +  4*mpcWindow, 1);</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;12*(mpcWindow+1); i++){</div><div class="line">        <span class="keywordtype">int</span> posQ=i%12;</div><div class="line">        <span class="keywordtype">float</span> value = Qx_ref(posQ,0);</div><div class="line">        gradient(i,0) = value;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> castMPCToQPConstraintMatrix(<span class="keyword">const</span> Eigen::Matrix&lt;double, 12, 12&gt; &amp;dynamicMatrix, <span class="keyword">const</span> Eigen::Matrix&lt;double, 12, 4&gt; &amp;controlMatrix,</div><div class="line">                                 <span class="keywordtype">int</span> mpcWindow, Eigen::SparseMatrix&lt;double&gt; &amp;constraintMatrix)</div><div class="line">{</div><div class="line">    constraintMatrix.resize(12*(mpcWindow+1)  + 12*(mpcWindow+1) + 4 * mpcWindow, 12*(mpcWindow+1) + 4 * mpcWindow);</div><div class="line"></div><div class="line">    <span class="comment">// populate linear constraint matrix</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;12*(mpcWindow+1); i++){</div><div class="line">        constraintMatrix.insert(i,i) = -1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; mpcWindow; i++)</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt;12; j++)</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;12; k++){</div><div class="line">                <span class="keywordtype">float</span> value = dynamicMatrix(j,k);</div><div class="line">                <span class="keywordflow">if</span>(value != 0){</div><div class="line">                    constraintMatrix.insert(12 * (i+1) + j, 12 * i + k) = value;</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; mpcWindow; i++)</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 12; j++)</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 4; k++){</div><div class="line">                <span class="keywordtype">float</span> value = controlMatrix(j,k);</div><div class="line">                <span class="keywordflow">if</span>(value != 0){</div><div class="line">                    constraintMatrix.insert(12*(i+1)+j, 4*i+k+12*(mpcWindow + 1)) = value;</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;12*(mpcWindow+1) + 4*mpcWindow; i++){</div><div class="line">        constraintMatrix.insert(i+(mpcWindow+1)*12,i) = 1;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> castMPCToQPConstraintVectors(<span class="keyword">const</span> Eigen::Matrix&lt;double, 12, 1&gt; &amp;xMax, <span class="keyword">const</span> Eigen::Matrix&lt;double, 12, 1&gt; &amp;xMin,</div><div class="line">                                   <span class="keyword">const</span> Eigen::Matrix&lt;double, 4, 1&gt; &amp;uMax, <span class="keyword">const</span> Eigen::Matrix&lt;double, 4, 1&gt; &amp;uMin,</div><div class="line">                                   <span class="keyword">const</span> Eigen::Matrix&lt;double, 12, 1&gt; &amp;x0,</div><div class="line">                                   <span class="keywordtype">int</span> mpcWindow, Eigen::VectorXd &amp;lowerBound, Eigen::VectorXd &amp;upperBound)</div><div class="line">{</div><div class="line">    <span class="comment">// evaluate the lower and the upper inequality vectors</span></div><div class="line">    Eigen::VectorXd lowerInequality = Eigen::MatrixXd::Zero(12*(mpcWindow+1) +  4 * mpcWindow, 1);</div><div class="line">    Eigen::VectorXd upperInequality = Eigen::MatrixXd::Zero(12*(mpcWindow+1) +  4 * mpcWindow, 1);</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;mpcWindow+1; i++){</div><div class="line">        lowerInequality.block(12*i,0,12,1) = xMin;</div><div class="line">        upperInequality.block(12*i,0,12,1) = xMax;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;mpcWindow; i++){</div><div class="line">        lowerInequality.block(4 * i + 12 * (mpcWindow + 1), 0, 4, 1) = uMin;</div><div class="line">        upperInequality.block(4 * i + 12 * (mpcWindow + 1), 0, 4, 1) = uMax;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// evaluate the lower and the upper equality vectors</span></div><div class="line">    Eigen::VectorXd lowerEquality = Eigen::MatrixXd::Zero(12*(mpcWindow+1),1 );</div><div class="line">    Eigen::VectorXd upperEquality;</div><div class="line">    lowerEquality.block(0,0,12,1) = -x0;</div><div class="line">    upperEquality = lowerEquality;</div><div class="line">    lowerEquality = lowerEquality;</div><div class="line"></div><div class="line">    <span class="comment">// merge inequality and equality vectors</span></div><div class="line">    lowerBound = Eigen::MatrixXd::Zero(2*12*(mpcWindow+1) +  4*mpcWindow,1 );</div><div class="line">    lowerBound &lt;&lt; lowerEquality,</div><div class="line">        lowerInequality;</div><div class="line"></div><div class="line">    upperBound = Eigen::MatrixXd::Zero(2*12*(mpcWindow+1) +  4*mpcWindow,1 );</div><div class="line">    upperBound &lt;&lt; upperEquality,</div><div class="line">        upperInequality;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> updateConstraintVectors(<span class="keyword">const</span> Eigen::Matrix&lt;double, 12, 1&gt; &amp;x0,</div><div class="line">                             Eigen::VectorXd &amp;lowerBound, Eigen::VectorXd &amp;upperBound)</div><div class="line">{</div><div class="line">    lowerBound.block(0,0,12,1) = -x0;</div><div class="line">    upperBound.block(0,0,12,1) = -x0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> getErrorNorm(<span class="keyword">const</span> Eigen::Matrix&lt;double, 12, 1&gt; &amp;x,</div><div class="line">                    <span class="keyword">const</span> Eigen::Matrix&lt;double, 12, 1&gt; &amp;xRef)</div><div class="line">{</div><div class="line">    <span class="comment">// evaluate the error</span></div><div class="line">    Eigen::Matrix&lt;double, 12, 1&gt; error = x - xRef;</div><div class="line"></div><div class="line">    <span class="comment">// return the norm</span></div><div class="line">    <span class="keywordflow">return</span> error.norm();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// set the preview window</span></div><div class="line">    <span class="keywordtype">int</span> mpcWindow = 20;</div><div class="line"></div><div class="line">    <span class="comment">// allocate the dynamics matrices</span></div><div class="line">    Eigen::Matrix&lt;double, 12, 12&gt; a;</div><div class="line">    Eigen::Matrix&lt;double, 12, 4&gt; b;</div><div class="line"></div><div class="line">    <span class="comment">// allocate the constraints vector</span></div><div class="line">    Eigen::Matrix&lt;double, 12, 1&gt; xMax;</div><div class="line">    Eigen::Matrix&lt;double, 12, 1&gt; xMin;</div><div class="line">    Eigen::Matrix&lt;double, 4, 1&gt; uMax;</div><div class="line">    Eigen::Matrix&lt;double, 4, 1&gt; uMin;</div><div class="line"></div><div class="line">    <span class="comment">// allocate the weight matrices</span></div><div class="line">    Eigen::DiagonalMatrix&lt;double, 12&gt; Q;</div><div class="line">    Eigen::DiagonalMatrix&lt;double, 4&gt; R;</div><div class="line"></div><div class="line">    <span class="comment">// allocate the initial and the reference state space</span></div><div class="line">    Eigen::Matrix&lt;double, 12, 1&gt; x0;</div><div class="line">    Eigen::Matrix&lt;double, 12, 1&gt; xRef;</div><div class="line"></div><div class="line">    <span class="comment">// allocate QP problem matrices and vectores</span></div><div class="line">    Eigen::SparseMatrix&lt;double&gt; hessian;</div><div class="line">    Eigen::VectorXd gradient;</div><div class="line">    Eigen::SparseMatrix&lt;double&gt; linearMatrix;</div><div class="line">    Eigen::VectorXd lowerBound;</div><div class="line">    Eigen::VectorXd upperBound;</div><div class="line"></div><div class="line">    <span class="comment">// set the initial and the desired states</span></div><div class="line">    x0 &lt;&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;</div><div class="line">    xRef &lt;&lt;  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0;</div><div class="line"></div><div class="line">    <span class="comment">// set MPC problem quantities</span></div><div class="line">    setDynamicsMatrices(a, b);</div><div class="line">    setInequalityConstraints(xMax, xMin, uMax, uMin);</div><div class="line">    setWeightMatrices(Q, R);</div><div class="line"></div><div class="line">    <span class="comment">// cast the MPC problem as QP problem</span></div><div class="line">    castMPCToQPHessian(Q, R, mpcWindow, hessian);</div><div class="line">    castMPCToQPGradient(Q, xRef, mpcWindow, gradient);</div><div class="line">    castMPCToQPConstraintMatrix(a, b, mpcWindow, linearMatrix);</div><div class="line">    castMPCToQPConstraintVectors(xMax, xMin, uMax, uMin, x0, mpcWindow, lowerBound, upperBound);</div><div class="line"></div><div class="line">    <span class="comment">// instantiate the solver</span></div><div class="line">    <a class="code" href="classOsqpEigen_1_1Solver.html">OsqpEigen::Solver</a> solver;</div><div class="line"></div><div class="line">    <span class="comment">// settings</span></div><div class="line">    <span class="comment">//solver.settings()-&gt;setVerbosity(false);</span></div><div class="line">    solver.<a class="code" href="classOsqpEigen_1_1Solver.html#ad355be214417b0ccb1ec54913fe378c4">settings</a>()-&gt;setWarmStart(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// set the initial data of the QP solver</span></div><div class="line">    solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setNumberOfVariables(12 * (mpcWindow + 1) + 4 * mpcWindow);</div><div class="line">    solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setNumberOfConstraints(2 * 12 * (mpcWindow + 1) +  4 * mpcWindow);</div><div class="line">    <span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setHessianMatrix(hessian)) <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setGradient(gradient)) <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setLinearConstraintsMatrix(linearMatrix)) <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setLowerBound(lowerBound)) <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a2d93b3aae416bc29abe5fb1db16333e0">data</a>()-&gt;setUpperBound(upperBound)) <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">    <span class="comment">// instantiate the solver</span></div><div class="line">    <span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a8487090a685d7653ea4011971c2f21f7">initSolver</a>()) <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">    <span class="comment">// controller input and QPSolution vector</span></div><div class="line">    Eigen::Vector4d ctr;</div><div class="line">    Eigen::VectorXd QPSolution;</div><div class="line"></div><div class="line">    <span class="comment">// number of iteration steps</span></div><div class="line">    <span class="keywordtype">int</span> numberOfSteps = 50;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numberOfSteps; i++){</div><div class="line"></div><div class="line">        <span class="comment">// solve the QP problem</span></div><div class="line">        <span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#aade83b0e68b85d47d41a054f04d413aa">solve</a>()) <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">        <span class="comment">// get the controller input</span></div><div class="line">        QPSolution = solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a192a5f94034d4e467c6b557c2e06dd66">getSolution</a>();</div><div class="line">        ctr = QPSolution.block(12 * (mpcWindow + 1), 0, 4, 1);</div><div class="line"></div><div class="line">        <span class="comment">// save data into file</span></div><div class="line">        <span class="keyword">auto</span> x0Data = x0.data();</div><div class="line"></div><div class="line">        <span class="comment">// propagate the model</span></div><div class="line">        x0 = a * x0 + b * ctr;</div><div class="line"></div><div class="line">        <span class="comment">// update the constraint bound</span></div><div class="line">        updateConstraintVectors(x0, lowerBound, upperBound);</div><div class="line">        <span class="keywordflow">if</span>(!solver.<a class="code" href="classOsqpEigen_1_1Solver.html#a1af39f37500a6bad6896e8e6699880fa">updateBounds</a>(lowerBound, upperBound)) <span class="keywordflow">return</span> 1;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The example presented generates the following results </p><div class="image">
<img src="mpc_result.png" alt="mpc_result.png"/>
</div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
